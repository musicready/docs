---
title: "The Problem & Why MRS is Feasible"
description: "A clear statement of the problem MRS solves and why this approach will work for AI-driven composition at professional scale."
---

## The Vision

**MRS enables AI-driven composition of full orchestral works—symphonies, vocal arrangements, film scores—through iterative conversation with humans in the loop.**

Think of it as "the opencode of Dorico": professional-grade notation infrastructure designed from the ground up for agent-driven workflows, where you can go from a chord chart or initial sketch to a fully orchestrated symphony through AI collaboration.

This is not a simplified demo. This is the hardest version of the problem: creating complex, multi-movement works from scratch, iteratively, with the granularity required for professional Dorico-level projects.

---

## The Core Problem

AI cannot currently compose or edit full orchestral scores reliably. Three fundamental challenges block progress:

### 1. The Scale Problem

A full orchestral score is too large for any AI context window:

| Score Type | Parts | Measures | Events | Tokens |
|------------|-------|----------|--------|--------|
| Lead sheet | 1 | 32 | ~200 | ~2K |
| Piano sonata | 2 | 300 | ~5,000 | ~40K |
| String quartet | 4 | 400 | ~8,000 | ~65K |
| Full orchestra | 90 | 1000 | ~200,000 | ~1.5M |

No LLM can hold a full orchestral score. More importantly, it shouldn't have to. Editing measure 847 should not require loading measures 1–846.

### 2. The Context Problem

Musical decisions require understanding surrounding material. Writing a clarinet countermelody requires knowing:
- What melodic material it responds to
- The harmonic context (what chords are sounding)
- Where phrase boundaries fall
- What comes before and after

Simple "slice some measures as text" approaches fail because music is structurally entangled: meter, phrasing, harmony, and spans (slurs, hairpins, pedal) all interact across measure boundaries.

### 3. The Structural Fragility Problem

Existing formats use positional references that break during editing:
- Insert a measure → all measure numbers after it change
- Delete a section → references to "measure 45" now point to wrong content
- If an LLM miscounts one duration, all subsequent events are misaligned

Implicit state creates cascading errors. One mistake propagates through the entire score.

---

## Why Existing Solutions Fail

### MusicXML / MEI
- **Too verbose**: A simple melody requires hundreds of lines of XML
- **No context management**: No built-in mechanism for bounded editing with context
- **Positional references**: Break on structural changes
- **Not agent-friendly**: Designed for interchange between notation apps, not AI workflows

### ABC Notation / LilyPond
- **No formal grammar**: Ambiguous parsing, especially for complex scores
- **No stable identity**: No UUIDs, no way to reference "this specific note" across edits
- **Human-entry optimized**: Shortcuts and abbreviations that confuse machine generation

### MIDI
- **No semantic content**: Pure performance data, no notation semantics
- **No structure**: No measures, no phrase boundaries, no form

---

## The MRS Solution

MRS solves these problems through three key design decisions:

### 1. UUID-First Identity

Every measure, event, and span carries a stable UUIDv7 identifier:

```clojure
(measure 
  :id #uuid "018c3f40-002d-7890-abcd-ef1234567890"  ; Stable—survives edits
  :number 45                                         ; Display only—can change
  :beat-start 487+1/4
  ...)
```

- `:id` is immutable and used for all internal references
- `:number` is for human navigation only
- Insert or delete measures → UUIDs remain stable, references survive

### 2. Working Set Envelopes with Context

Instead of giving AI the whole score or just a slice, MRS provides **bounded fragments with graduated context**:

```
Full Score (6MB, 1.5M tokens)
         │
         ▼ extract
┌─────────────────────────────────────────┐
│  Working Set Envelope                    │
│                                          │
│  :content        Full detail (writable)  │
│  :context-near   Adjacent (read-only)    │
│  :context-far    Distant (reduced)       │
│  :synopsis-ref   Structural overview     │
└─────────────────────────────────────────┘
         │
         ▼ agent edits
         │
         ▼ replace
Full Score (updated)
```

Agents see what they need, nothing more. Context rings provide surrounding material at graduated detail levels. Synopsis provides global structural awareness.

### 3. Single Syntax Throughout

Agents receive valid MRS-S and return valid MRS-S. No second format, no abbreviations, no conversion step. Extraction and replacement are trivial operations:

```
replace(S, identity(extract(S, P))) ≡ S
```

---

## Why This Approach is Feasible

### The Scale Problem → Solved by Scoped Extraction

Working Set Envelopes reduce a 1.5M token orchestral score to a focused fragment (typically 5-50K tokens) with appropriate context. Agents operate on bounded regions while understanding their surroundings.

### The Context Problem → Solved by Context Rings + Synopsis

Context rings provide graduated detail: full resolution nearby, reduced detail farther out. Synopsis provides structural overview (form, key areas, thematic material) without loading full content.

### The Structural Fragility Problem → Solved by UUID Identity

All references use stable UUIDs. Insert measures, delete sections, reorder movements—references survive because they point to identity, not position.

### The Iteration Problem → Solved by the Orchestrator Pattern

A single-writer orchestrator coordinates multiple specialist agents:

```
         ORCHESTRATOR (owns canonical state)
         │         │         │         │
         ▼         ▼         ▼         ▼
     Harmony    Melody    Orch.    Expression
     Agent      Agent     Agent      Agent
```

Agents can run in parallel, but only the orchestrator commits changes. This avoids multi-writer complexity while enabling multi-agent power.

---

## The Hardest Version of the Problem

MRS is designed for the most demanding case: **creating a symphony from scratch, iteratively, through AI conversation**.

This means supporting:

1. **Structural creation**: Insert measures, sections, movements—not just edit existing content
2. **Incomplete states**: Early-stage work has placeholders ("strings texture TBD", "orchestrate later")
3. **Cross-boundary spans**: Hairpins, slurs, pedal marks that cross edit boundaries
4. **Human-in-the-loop checkpoints**: Lock form, lock harmony, lock orchestration at appropriate stages
5. **Conflict-free iteration**: Multiple agents contributing without destructive overwrites

If MRS handles symphonies-from-scratch, it handles everything simpler too.

---

## What Makes This Achievable

### 1. The Orchestrator is the Product

The core IP is not the syntax—it's the **orchestrator + validation + merge semantics**. MRS-S is the canonical representation; the orchestrator is what makes iterative composition safe and reliable.

### 2. AI Quality Will Improve

MRS doesn't require AI to be perfect. It provides:
- **Safety rails**: Validation catches errors before they propagate
- **Bounded scope**: Mistakes are contained to the working set
- **Human review gates**: Checkpoints for approval before proceeding

As AI improves, the system captures that improvement. As AI makes errors, the system contains them.

### 3. Human-in-the-Loop is a Feature

Professional composition is inherently collaborative. MRS supports:
- Human approval at structural checkpoints
- Intelligible diffs for reviewing AI changes
- Playback preview integration
- The ability to lock decisions ("form is final") and iterate on details

---

## Feasibility Summary

| Challenge | Solution | Feasibility |
|-----------|----------|-------------|
| Scale (scores too large) | Working Set Envelopes with scoped extraction | **Solved** |
| Context (decisions need surroundings) | Context rings + Synopsis | **Solved** |
| Structural fragility (references break) | UUID-first identity | **Solved** |
| Safe iteration (edits conflict) | Single-writer orchestrator + edit lanes | **Achievable** |
| From-scratch composition | Draft states + checkpoints + HarmonyPlan layer | **Achievable** |
| Span safety (hairpins break) | Boundary rules + span repair protocol | **Achievable** |

The approach is **feasible**. The core architectural decisions are sound. What remains is disciplined implementation of the orchestrator semantics—edit lanes, transaction model, checkpoint enforcement—which are well-understood problems with clear solutions.

---

## Next Steps

The following specifications complete the architecture for professional-scale AI composition:

- [Orchestrator Contract](/orchestrator-contract) — Edit lanes, transaction model, merge semantics
- [Draft States](/draft-states) — Placeholder primitives for from-scratch composition
- [Working Set Envelope](/working-set-envelope) — Scope grants with lane permissions

See also:
- [Design Principles](/design-principles) — Core philosophy
- [Architecture Overview](/architecture-overview) — Component relationships
- [Extract-Replace Protocol](/extract-replace-protocol) — How extraction and replacement work
